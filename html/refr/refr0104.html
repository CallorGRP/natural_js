<article id="refr0104" class="apiDoc">
	<h1>Natural-DATA</h1>

<div id="ndTab">
<ul>
	<li><a href="#tab1">Formatter</a></li>
	<li><a href="#tab2">포멧 룰</a></li>
	<li><a href="#tab3">Validator</a></li>
	<li><a href="#tab4">검증 룰</a></li>
	<li><a href="#tab5">Natural-DATA Libraries</a></li>
</ul>
<div id="tab1">
	<h2>Formatter(N.formatter)</h2>

	<h3>가. 개요</h3>
	<p>Formatter 는 지정한 데이터세트를 정의한 룰을 기반으로 데이터세트 전체를 양식화하여 반환 합니다. 룰(rules) 대신 입력요소가 담겨있는 블록요소(Block element)를 지정하면 입력요소에 선언형 옵션으로 지정된 룰을 기반으로 양식화하여 반환 해 주는 라이브러리입니다.</p>

	<p class="alert">
	룰 대신 입력요소를 지정하면 해당 입력요소들마다 "format", "unformat" 이벤트를 바인드(bind) 해 줍니다.
	해당 입력요소를 가져다가 jQuery 의 trigger 메서드로 실행하면 해당입력요소에 입력된 값을 실시간으로 format, unformat 할 수 있습니다.</p>

	<pre><code>N("input[name='formatEx']").trigger("format or unformat");</code></pre>

	<h3>나. 생성자(Constructor)</h3>
	<table class="form">
		<tr>
			<th>Name</th>
			<th>Arguments</th>
			<th>Type</th>
			<th>Return</th>
			<th style="width: auto;">Description</th>
		</tr>
		<tr>
			<td>N.formatter</td>
			<td align="center">-</td>
			<td align="center">-</td>
			<td>N.formatter</td>
			<td>N.formatter 객체를 생성 합니다.</td>
		</tr>
		<tr>
			<td></td>
			<td>obj</td>
			<td>JSON Object</td>
			<td align="center">-</td>
			<td>양식화할 데이터를 지정 합니다. 데이터는 JSON Array 타입으로 입력 해야 합니다.</td>
		</tr>
		<tr>
			<td></td>
			<td>rules</td>
			<td>JSON Object or JWS(elements)</td>
			<td align="center">-</td>
			<td>
				<p>룰은 다음과 같이 두가지 형태로 지정 가능 합니다.</p>
				<p>* 라이브러리 초기화 시 명령형 옵션으로 지정 : </p>
				<pre><code>{
	&quot;numeric&quot; : [[&quot;trimtoempty&quot;], [&quot;numeric&quot;, &quot;#,###.##0000&quot;]],
	&quot;generic&quot; : [[&quot;trimtoempty&quot;], [&quot;generic&quot;, &quot;@@ABCD&quot;]],
	&quot;limit&quot; : [[&quot;trimtoempty&quot;], [&quot;limit&quot;, &quot;13&quot;, &quot;...&quot;]],
	&quot;etc&quot; : [[&quot;date&quot;, 12]]
}</code></pre>
				<p>* data-format 속성에 선언형 옵션으로 지정 : </p>
				<pre><code>&lt;input id="limit" type="text" data-format='[[&quot;trimtoempty&quot;], [&quot;limit&quot;, &quot;13&quot;, &quot;...&quot; ]]' /&gt;</code></pre>
[ ["룰명", "룰arguments[0]", "룰 arguments[1]"], ... ]
			</td>
		</tr>
		<tr>
			<td>N(obj).formatter</td>
			<td align="center">-</td>
			<td align="center">-</td>
			<td>N.formatter</td>
			<td>
				<p>N.formatter를 플러그인 방식으로의 초기화 방식입니다.</p>
				<p>N.formatter와 동작되는 로직은 같으며 실제 N() 의 인자로 들어온 값이 N.formatter()의 첫 번째 인자로 지정 됩니다.</p>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>rules</td>
			<td>JSON Object or JWS(elements)</td>
			<td align="center">-</td>
			<td>N.formatter의 rules 인자 와 같습니다.</td>
		</tr>
	</table>

	<h3>다. 함수(Methods)</h3>
	<table class="form">
		<tr>
			<th>Name</th>
			<th>Arguments</th>
			<th>Type</th>
			<th>Return</th>
			<th style="width: auto;">Description</th>
		</tr>
		<tr>
			<td>format</td>
			<td align="center">-</td>
			<td align="center">-</td>
			<td>양식화된 데이터세트(JSON)</td>
			<td>데이터 양식화를 실행합니다.</td>
		</tr>
		<tr>
			<td></td>
			<td>row</td>
			<td>int</td>
			<td align="center">-</td>
			<td colspan="2">
				<p>양식화할 데이터의 row, </p>
				<p>입력하지 않으면 무조건 첫 번째 데이터를 양식화 합니다.</p>
			</td>
		</tr>
		<tr>
			<td>unformat</td>
			<td align="center">-</td>
			<td align="center">-</td>
			<td>양식화 되지않은 데이터(JSON)</td>
			<td>원(元)데이터를 반환합니다.</td>
		</tr>
		<tr>
			<td></td>
			<td>row</td>
			<td>int</td>
			<td align="center">-</td>
			<td>양식화 되지않은 원(元)데이터를 반환 할 row</td>
		</tr>
		<tr>
			<td></td>
			<td>key</td>
			<td>String</td>
			<td align="center">-</td>
			<td>양식화 되지않은 원(元)데이터(JSON Object)의 key 값</td>
		</tr>
	</table>
</div>

<div id="tab2">
	<h3>라. 포맷 룰(Format rules)</h3>
	<table class="form">
		<tr>
			<th style="width: 200px;">옵션명</th>
			<th style="width: auto;">설명</th>
		</tr>
		<tr>
			<td>["ssn"]</td>
			<td>주민등록번호 형식으로 변경</td>
		</tr>
		<tr>
			<td>["cno"]</td>
			<td>사업자등록번호 형식으로 변경</td>
		</tr>
		<tr>
			<td>["upper"]</td>
			<td>대문자로 변경</td>
		</tr>
		<tr>
			<td>["lower"]</td>
			<td>소문자로 변경</td>
		</tr>
		<tr>
			<td>["capitalize"]</td>
			<td>첫번째 영문자를 대문자로 변경</td>
		</tr>
		<tr>
			<td>["zipcode"]</td>
			<td>우편번호 형식으로 변경</td>
		</tr>
		<tr>
			<td>["phoneNum"]</td>
			<td>전화번호 형식으로 변경</td>
		</tr>
		<tr>
			<td>["realnum"]</td>
			<td>
				<p>의미없는 0 제거</p>
				<p>ex)</p>
				<p>0100.0 -&gt; 100</p>
				<p>0100.10 -&gt; 100.1</p>
			</td>
		</tr>
		<tr>
			<td>["trimToEmpty"]</td>
			<td>trim 후 값이 없으면 공백으로 표시</td>
		</tr>
		<tr>
			<td>["trimToZero"]</td>
			<td>trim 후 값이 없으면 0 으로 표시</td>
		</tr>
		<tr>
			<td>["trimToVal", "valStr"]</td>
			<td>trim 후 값이 없으면 valStr 값으로 표시</td>
		</tr>
		<tr>
			<td>["date",  4|6|8|10|12|14|"month"|"date"]</td>
			<td>
				<p>날짜 형식으로 표시. </p>
				<p>기본 날짜형식은 N.context.attr(&quot;data&quot;).formatter.date에서 설정 가능 합니다.</p>
				<p>다음은 두 번째 값들에 대한 설명 입니다.</p>
				<p> * month : Monthpicker 표시</p>
				<p> * date : Datepicker 표시 </p>
				<p> * 4:년</p>
				<p> * 6:년-월</p>
				<p> * 8:년-월-일</p>
				<p> * 10:년-월-일 시</p>
				<p> * 12:년-월-일 시:분</p>
				<p> * 14:년-월-일 시:분:초</p>
			</td>
		</tr>
		<tr>
			<td>["limit, cutLength, "replaceStr"]</td>
			<td>문자열을 cutLength 만큼 자르고 replaceStr로 치환</td>
		</tr>
		<tr>
			<td>["replace", "targetStr", "replaceStr"]</td>
			<td>targetStr을 replaceStr로 치환</td>
		</tr>
		<tr>
			<td>["lpad", length "fillStr"]</td>
			<td>length만큼 왼쪽부터 replaceStr문자로 채움</td>
		</tr>
		<tr>
			<td>["rpad", length "fillStr"]</td>
			<td>length만큼 오른쪽부터 replaceStr문자로 채움</td>
		</tr>
		<tr>
			<td>["generic", "사용자서식"]</td>
			<td>
				<p>엑셀 사용자지정 서식과 같이 사용자 서식을 이용하여 문자열을 양식화</p>
				<p> * # : 숫자</p>
				<p> * @ : 영문자</p>
				<p>ex)</p>
				<p> * 10000123 -&gt; \#,###.### -&gt; \1,000.123</p>
			</td>
		</tr>
		<tr>
			<td>["numeric" "사용자서식", "option"]</td>
			<td>
				<p>엑셀 사용자지정 서식과 같이 사용자 서식을 이용하여 숫자를 양식화</p>
				<p>option 값를 이용하여 소숫점을 다음과 같이 처리</p>
				<p> * option 값</p>
				<p> ceil : 무조건올림 (소수점 처리가능)</p>
				<p> floor : 무조건버림(소수점 처리가능)</p>
				<p> round : 반올림(소수점 처리가능)</p>
				<p>ex)</p>
				<p> * 1,2 -&gt; #,##0 -&gt; 1,200</p>
			</td>
		</tr>
	</table>
</div>

<div id="tab3">
	<h2>Validator(N.validator)</h2>

	<h3>가. 개요</h3>
	<p>Validator 는 지정한 데이터세트를 정의한 룰을 기반으로 데이터세트 전체를 검증하여 검증 데이터 세트를 반환해 주는 라이브러리입니다. 룰(rules) 대신 입력요소가 담겨있는 블록요소(Block element)를 지정하면 입력요소에 선언형옵션으로 지정된 룰을 기반으로 검증을 하여 검증에 통과하지 못했다면 입력요소 바로옆에 툴팁으로 검증 메시지를 보여줍니다.</p>

	<h3>나. 생성자(Constructor)</h3>
	<table class="form">
		<tr>
			<th>Name</th>
			<th>Arguments</th>
			<th>Type</th>
			<th>Return</th>
			<th style="width: auto;">Description</th>
		</tr>
		<tr>
			<td>N.validator</td>
			<td align="center">-</td>
			<td align="center">-</td>
			<td>N.validator</td>
			<td>N.validator 객체를 생성 합니다.</td>
		</tr>
		<tr>
			<td></td>
			<td>obj</td>
			<td>JSON Object</td>
			<td align="center">-</td>
			<td>검증할 데이터세트를 지정 합니다. 데이터는 JSON Array 타입으로 입력 해야 합니다.</td>
		</tr>
		<tr>
			<td></td>
			<td>rules</td>
			<td>JSON Object or JWS(elements)</td>
			<td align="center">-</td>
			<td>
				<p>룰을 JSON Object 형태로 지정 하거나</p>
				<p>ex)</p>
				<p>{</p>
				<p>  &quot;numeric&quot; : [[&quot;required&quot;], [&quot;integer+commas&quot;]],</p>
				<p>  &quot;generic&quot; : [[&quot;required&quot;], [&quot;korean&quot;]],</p>
				<p>  &quot;limit&quot; : [[&quot;required&quot;], [&quot;alphabet&quot;]]</p>
				<p>}</p>
				<p>선언형옵션으로 룰이 지정된 입력요소나 입력요소 블록을 지정 합니다.</p>
				<p>ex)</p>
				<p>&lt;input id="numeric" type="text" data-validate='[[&quot;required&quot;], [&quot;integer+commas&quot;]]'/&gt;</p>

				<p>[ ["룰명", "룰arguments[0]", "룰 arguments[1]"], ... ]</p>
			</td>
		</tr>
		<tr>
			<td>N(obj).validator</td>
			<td align="center">-</td>
			<td align="center">-</td>
			<td>N.validator</td>
			<td>
				<p>N.validator를 플러그인 방식으로의 초기화 방식입니다.</p>
				<p>N.validator와 동작되는 로직은 같으며 실제 N() 의 인자로 들어온 값이 N.validator()의 첫 번째 인자로 지정 됩니다.</p>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>rules</td>
			<td>JSON Object or JWS(elements)</td>
			<td align="center">-</td>
			<td>N.validator의 rules 인자 와 같습니다.</td>
		</tr>
	</table>

	<h3>다. 함수(Methods)</h3>
	<table class="form">
		<tr>
			<th>Name</th>
			<th>Arguments</th>
			<th>Type</th>
			<th>Return</th>
			<th style="width: auto;">Description</th>
		</tr>
		<tr>
			<td>validate</td>
			<td align="center">-</td>
			<td align="center">-</td>
			<td>데이터의 컬럼별 검증결과 데이터</td>
			<td>데이터 검증을 실행합니다.</td>
		</tr>
		<tr>
			<td></td>
			<td>row</td>
			<td>int</td>
			<td align="center">-</td>
			<td colspan="2">
				<p>검증할 데이터의 row, </p>
				<p>입력하지 않으면 무조건 첫 번째 데이터를 양식화 합니다.</p>
			</td>
		</tr>
	</table>
</div>

<div id="tab4">
	<h3>라. 검증 룰(Validate rules)</h3>
	<table class="form">
		<tr>
			<th style="width: 200px;">옵션명</th>
			<th style="width: auto;">설명</th>
		</tr>
		<tr>
			<td>["required"]</td>
			<td>필수입력</td>
		</tr>
		<tr>
			<td>["alphabet"]</td>
			<td>영문자만 입력 가능</td>
		</tr>
		<tr>
			<td>["integer"]</td>
			<td>숫자(정수)만 입력가능</td>
		</tr>
		<tr>
			<td>["Korean"]</td>
			<td>한글만 입력 가능</td>
		</tr>
		<tr>
			<td>["alphabet+integer"]</td>
			<td>영문자와 숫자(정수)만 입력 가능(+로 구분하고 순서는 관계없음)</td>
		</tr>
		<tr>
			<td>["integer+korean"]</td>
			<td>숫자(정수)와 한글만 입력 가능(+로 구분하고 순서는 관계없음)</td>
		</tr>
		<tr>
			<td>["alphabet+korean"]</td>
			<td>영문자와 한글만 입력 가능(+로 구분하고 순서는 관계없음)</td>
		</tr>
		<tr>
			<td>["alphabet+integer+korean"]</td>
			<td>영문자, 숫자(정수), 한글만 입력 가능(+로 구분하고 순서는 관계없음)</td>
		</tr>
		<tr>
			<td>["integer+dash"]</td>
			<td>숫자(정수), 대시(-)만 입력가능(+로 구분하고 순서는 관계없음)</td>
		</tr>
		<tr>
			<td>["integer+commas"]</td>
			<td>숫자(정수), 콤마(,)만 입력가능(+로 구분하고 순서는 관계없음)</td>
		</tr>
		<tr>
			<td>["number"]</td>
			<td>숫자(정수), 대시(,), 점(.)만 입력가능</td>
		</tr>
		<tr>
			<td>["decimal(length)"]</td>
			<td>(유한)소수 length 번째 자리까지 입력 가능</td>
		</tr>
		<tr>
			<td>["email"]</td>
			<td>e-mail 형식에 맞는지 검사</td>
		</tr>
		<tr>
			<td>["url"]</td>
			<td>URL 형식에 맞는지 검사</td>
		</tr>
		<tr>
			<td>["zipcode"]</td>
			<td>우편번호 형식에 맞는지 검사</td>
		</tr>
		<tr>
			<td>["frn"]</td>
			<td>외국인등록번호 형식에 맞지 검사</td>
		</tr>
		<tr>
			<td>["ssn"]</td>
			<td>주민등록번호 형식에 맞지 검사</td>
		</tr>
		<tr>
			<td>["cno"]</td>
			<td>사업자등록번호 형식에 맞는지 검사</td>
		</tr>
		<tr>
			<td>["cpno"]</td>
			<td>법인번호 형식에 맞는지 검사</td>
		</tr>
		<tr>
			<td>["date"]</td>
			<td>날짜 형식에 맞는지 검사</td>
		</tr>
		<tr>
			<td>["time"]</td>
			<td>시간 형식에 맞는지 검사</td>
		</tr>
		<tr>
			<td>["accept", "word"]</td>
			<td>word 값만 입력 가능</td>
		</tr>
		<tr>
			<td>["match", "word"]</td>
			<td>word 값이 포함된 값만 입력 가능</td>
		</tr>
		<tr>
			<td>["acceptFileExt", "ext"]</td>
			<td>ext 값이 포함된 확장자만 입력 가능</td>
		</tr>
		<tr>
			<td>["notAccept", "word""]</td>
			<td>word 값만 입력 불가능</td>
		</tr>
		<tr>
			<td>["notMatch", "word"]</td>
			<td>word 가 포함된 값은 입력 불가능</td>
		</tr>
		<tr>
			<td>["notAcceptFileExt", "ext"]</td>
			<td>ext 가 포함된 확장자는 입력 불가능</td>
		</tr>
		<tr>
			<td>["equalTo", "input"]</td>
			<td>input 의 값과 같아야 함</td>
		</tr>
		<tr>
			<td>["maxlength", "length"]</td>
			<td>length 글자 이하만 입력 가능</td>
		</tr>
		<tr>
			<td>["minlength", "length"]</td>
			<td>length 글자 이상만 입력 가능</td>
		</tr>
		<tr>
			<td>["rangelength", "startLength", "endLength"]</td>
			<td>stratLength 글자 에서   endLength 글자 까지만 입력 가능</td>
		</tr>
		<tr>
			<td>["maxbyte", "byteLength"]</td>
			<td>length 바이트 이하만 입력 가능</td>
		</tr>
		<tr>
			<td>["minbyte", "byteLength"]</td>
			<td>length 바이트 이상만 입력 가능</td>
		</tr>
		<tr>
			<td>["rangebyte", "startByteLength", "endByteLength"]</td>
			<td>startByteLength 바이트 에서 endByteLength 바이트 까지만 입력 가능</td>
		</tr>
		<tr>
			<td>["maxvalue", "value"]</td>
			<td>value 이하의 값만 입력 가능</td>
		</tr>
		<tr>
			<td>["minvalue", "value"]</td>
			<td>value 이상의 값만 입력 가능</td>
		</tr>
		<tr>
			<td>["rangevalue", "stratValue,endValue"]</td>
			<td>stratValue 값 에서   endValue 값 까지만 입력 가능</td>
		</tr>
		<tr>
			<td>["regexp", "regexp", "message"]</td>
			<td>입력한 regexp 의 조건으로 검사 후 message 값 표시</td>
		</tr>
	</table>
</div>

<div id="tab5">
	<h2>Natural-DATA Libraries</h2>

	<h3>가. 개요</h3>
	<p>Natural-DATA 패키지에는 JSON Array 타입의 데이터를 조작하고 정령할 수 있는 기능을 제공 합니다.</p>

	<h3>나. 함수(Methods)</h3>


	<table class="form">
		<tr>
			<th>Name</th>
			<th>Arguments</th>
			<th>Type</th>
			<th>Return</th>
			<th style="width: auto;">Description</th>
		</tr>
		<tr>
			<td>N.data.refine</td>
			<td align="center">-</td>
			<td align="center">-</td>
			<td>정제된 JSON Array</td>
			<td>서버나 JSON 데이터가 담긴 파일에서 가져온 JSON 데이터를 Natural-JS에서 사용할수 있는 형태의 JSON 형태로 만들어 줍니다.</td>
		</tr>
		<tr>
			<td></td>
			<td>obj</td>
			<td>JSON Array</td>
			<td align="center">-</td>
			<td>정제 할 데이터</td>
		</tr>
		<tr>
			<td></td>
			<td>listId</td>
			<td>String</td>
			<td align="center">-</td>
			<td>서버나 JSON 데이터가 담긴 파일에서 여러개의 리스트를 반환했을경우의 해당 리스트의 ID 값</td>
		</tr>
		<tr>
			<td>N.data.filter</td>
			<td align="center">-</td>
			<td align="center">-</td>
			<td>필터링된 JSON Array</td>
			<td>지정한 조건으로 JSON Array를 필터링 합니다.</td>
		</tr>
		<tr>
			<td></td>
			<td>arr</td>
			<td>JSON Array</td>
			<td></td>
			<td>필터링 할 데이터</td>
		</tr>
		<tr>
			<td></td>
			<td>queryString</td>
			<td>String</td>
			<td align="center">-</td>
			<td>
				<p>필터링 조건을 입력 합니다.</p>
				<p>조건은 다음과 같이 자바스크립트 비교 문법으로 지정 합니다.</p>
				<p>ex)</p>
				<p>* queryString = 'data.키명 == "비교값"';</p>
				<p>N.data.filter([</p>
				<p>  { name : "홍길동" }, </p>
				<p>  { name : "Mike" }</p>
				<p>);</p>
				<p>쉽게 생각하면 queryString 바깥에 if() 문이 감싸져있고 data 라고 이름지어진 row data를 가지고 비교한다고 생각 하면 됩니다.</p>
			</td>
		</tr>
		<tr>
			<td>N.data.sort</td>
			<td align="center">-</td>
			<td align="center">-</td>
			<td>정렬된 JSON Array</td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td>arr</td>
			<td>JSON Array</td>
			<td align="center">-</td>
			<td>정렬 할 데이터</td>
		</tr>
		<tr>
			<td></td>
			<td>key</td>
			<td>String</td>
			<td align="center">-</td>
			<td>정렬 기준이 될 key(컬럼) 명</td>
		</tr>
		<tr>
			<td></td>
			<td>reverse</td>
			<td>boolean</td>
			<td align="center">-</td>
			<td>오름차순(true), 내림차순(false) 선택</td>
		</tr>
		<tr>
			<td>N(obj).datarefine</td>
			<td align="center">-</td>
			<td align="center">-</td>
			<td>정제된 JSON Array</td>
			<td>
				<p>N.data.refine을 플러그인 방식으로 초기화 하는 방식입니다.</p>
				<p>N.data.refine과 동작되는 로직은 같으며 실제 N() 의 인자로 들어온 값이 N.data.refine()의 첫 번째 인자로 지정 됩니다.</p>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>listId</td>
			<td>String</td>
			<td align="center">-</td>
			<td>N.data.refine의 listId 인자 와 같습니다.</td>
		</tr>
		<tr>
			<td>N(obj).datafilter</td>
			<td align="center">-</td>
			<td align="center">-</td>
			<td>필터링된 JSON Array</td>
			<td>
				<p>N.data.filter를 플러그인 방식으로 초기화 하는 방식입니다.</p>
				<p>N.data.filter와 동작되는 로직은 같으며 실제 N() 의 인자로 들어온 값이 N.data.filter()의 첫 번째 인자로 지정 됩니다.</p>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>queryString</td>
			<td>JSON Array</td>
			<td></td>
			<td>N.data.filter의 queryString 인자 와 같습니다.</td>
		</tr>
		<tr>
			<td>N(obj).datasort</td>
			<td align="center">-</td>
			<td align="center">-</td>
			<td>정렬된 JSON Array</td>
			<td>
				<p>N.data.sort를 플러그인 방식으로 초기화 하는 방식입니다.</p>
				<p>N.data.sort와 동작되는 로직은 같으며 실제 N() 의 인자로 들어온 값이 N.data.sort()의 첫 번째 인자로 지정 됩니다.</p>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>key</td>
			<td>String</td>
			<td align="center">-</td>
			<td>N.data.sort의 key 인자 와 같습니다.</td>
		</tr>
		<tr>
			<td></td>
			<td>reverse</td>
			<td>boolean</td>
			<td align="center">-</td>
			<td>N.data.sort의 reverse 인자 와 같습니다.</td>
		</tr>
	</table>
</div>

</article>

<script type="text/javascript">
N("article#refr0104").cont({
    init : function(view, request) {
    	N("div#ndTab", view).tab();
    }
});
</script>